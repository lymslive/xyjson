# xyjson 性能测试

本目录包含 xyjson 相对于 yyjson 原生 C API 的相对性能测试套件。

## 重构后的性能测试方案

### 核心思想
使用相对性能测试方法，将 xyjson 作为被测函数，yyjson 原生 API 作为基准函数，测
试两者的相对性能开销。

### 关键特性
- **相对性能比较**：测试 xyjson 相对于 yyjson 的性能开销
- **动态迭代调整**：根据运行时自动调整迭代次数，确保测试时间达到设定阈值
- **命令行参数支持**：可动态调整运行时间和允许的开销阈值
- **业务正确性验证**：每个测试都包含 COUT 断言验证业务逻辑正确性

## 编译

```bash
# 在构建目录中（默认已开启优化）
cmake .. -DBUILD_PERF=ON
make perf_test

# 或使用根目录的 makefile
make release  # 编译 release 版本，包含性能测试
```

## 运行

```bash
# 运行所有性能测试
./perf_test

# 静默模式（仅显示失败和总结）
./perf_test --cout=silent

# 自定义运行时间和开销阈值（默认 --runtime_ms=200 --overhead_percent=5）
./perf_test --runtime_ms=500 --overhead_percent=10

# 运行特定测试
./perf_test access
./perf_test iterator
```

## 测试内容

### 1. 访问性能测试 (p_access.cpp)
- 不同规模数据的数组访问：100、1000、10000 个元素
- 不同规模数据的对象访问：100、1000、10000 个键
- 使用索引访问模式（非迭代器）

### 2. 迭代器性能测试 (p_iterator.cpp)
- 不同规模数据的数组迭代器：100、1000、10000 个元素
- 不同规模数据的对象迭代器：100、1000、10000 个键
- 使用迭代器遍历模式

### 3. 解析性能测试 (p_parse.cpp)
- 字符串解析性能
- 文件解析性能
- 不同大小数据集的解析性能

### 4. 组合操作测试 (p_chained.cpp)
- 链式操作性能
- 批量操作性能

## 核心函数

### `perf::relativePerformance()`
相对性能测试核心函数，参数：
- `test_name`: 被测函数名称（如 "xyjson array access"）
- `test_func`: 被测函数（xyjson 封装）
- `base_name`: 基准函数名称（如 "yyjson array access"）
- `base_func`: 基准函数（yyjson 原生 API）
- `iterations`: 初始迭代次数（默认 100）
- `min_time_ms`: 最小运行时间（毫秒，默认 200）
- `overhead_percent`: 允许的开销阈值（百分比，默认 5%）

### `perf::createJsonContainer(int n)`
创建标准测试数据：
- 包含长度为 n 的数组：`[0, 1, 2, ..., n-1]`
- 包含 n 个键的对象：`{"k0":0, "k1":1, ..., "kn-1":n-1}`
- 总和为：0+1+...+(n-1) = n*(n-1)/2

## 测试数据生成

所有测试用例使用动态生成的 JSON 数据，确保测试数据的可控性和可重复性。

## 结果输出格式

```
相对性能对比 - <测试名称>
  测试函数 (<测试名>): <平均时间> μs/次 (总: <总时间> μs, 次数: <次数>)
  基准函数 (<基准名>): <平均时间> μs/次 (总: <总时间> μs, 次数: <次数>)
  开销比: <倍数>×
  开销%: <百分比>%
  ✓ 性能测试通过 (允许开销: <允许开销>%)
  ✗ 性能测试不通过 (允许开销: <允许开销>%)
```

## 最近性能测试报告概要与说明

基于2025年11月20日进行的性能测试（使用500ms测试时间，5%允许开销阈值），以下是关键发现：

### 总体性能表现
- **总测试用例**：23个
- **平均通过率**：16-19个通过（69%-83%）
- **性能稳定领域**：复杂文件访问、嵌套访问、类型转换
- **待优化领域**：小文件解析、简单访问操作

### 关键性能亮点

#### 1. xyjson显著优势领域
- **复杂文件访问**：比yyjson快75-84%（极其稳定）
- **嵌套访问**：比yyjson快20-42%（性能优势稳定）
- **类型转换**：比yyjson快25%（浮度较大但趋势明确）

#### 2. 待优化领域
- **小文件解析**：比yyjson慢10-42%（浮动较大）
- **简单访问**：比yyjson慢10-26%（性能劣势稳定）
- **数组访问**：中等规模时存在5-40%不等的性能劣势

### 迭代器 vs 普通循环性能对比

#### 数组访问场景
- **小规模（10个元素）**：普通循环略优（1-6%优势）
- **中等规模（100个元素）**：普通循环明显更优（15-39%优势）
- **推荐**：数组处理优先使用普通循环索引

#### 对象访问场景
- **小规模（100个键）**：迭代器显著优势（普通循环慢数百倍）
- **中等规模（500个键）**：迭代器巨大优势（普通循环慢数百倍）
- **大规模（1000个键）**：迭代器优势更加明显
- **推荐**：对象处理强烈推荐使用迭代器

### 测试稳定性分析

#### 稳定用例（浮动<20%）
- access_complex_file（8%浮动）
- access_array_objects_3（16%浮动）
- access_object_1000（15%浮动）
- access_simple（15%浮动）

#### 浮动较大用例（浮动>30%）
- parse_medium（36%浮动）
- parse_large（40%浮动）
- parse_complex（41%浮动）
- access_object_500（39%浮动）

### 重构验证结果
✅ **函数重构完成**：所有用例成功从printComparison迁移到relativePerformance  
✅ **lambda捕获修正**：yyjson lambda统一使用yy_doc捕获，确保技术一致性  
✅ **对象访问对标**：xyjson和yyjson都使用键名访问，测试方法完全对标  
✅ **新用例运行正常**：新增的6个对象访问和迭代器用例全部通过测试

### 使用建议
1. **复杂结构处理**：优先使用xyjson（嵌套访问、复杂文件处理）
2. **简单操作**：需要优化（小文件解析、简单访问）
3. **数组访问**：使用普通循环索引
4. **对象访问**：使用迭代器遍历

### 测试环境参数
- **测试时间**：500ms（相比200ms提供更稳定结果）
- **允许开销**：5%
- **迭代次数**：动态调整（根据测试复杂度自动优化）
- **测试轮次**：3次独立运行取平均值
